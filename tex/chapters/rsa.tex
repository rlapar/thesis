\chapter{Public-Key Cryptosystems}

In this chapter, we will present basic overview of public-key cryptosystems, focusing mainly on the RSA, the most commonly and widely used public-key cryptosystem. 

\subsection*{Private-Key Cryptosystems}

Before 1977 every used cryptosystem was private-key (or symmetric), where both communicating parties Alice and Bob\footnote{in cryptographic terminology, two parties are commonly referred to as Alice and Bob} shared the same secret key. The secret key was then used for encryption and decryption respectively. However, the main issue was how to securely distribute shared secret key between Alice and Bob. Either completely secure channel was used with no eavesdropping possible, or some key exchange method like Diffie-Hellman key exchange\cite{diffie_hellman} was used. The problem of distribution of the private key served as the motivation behind the concept of public-key (assymetric) cryptosystem invented by Diffie and Hellman \cite{diffie_hellman}. Public-key cryptosystems are undoubtedly the building blocks of modern cryptography and internet security as of today. In practice, we use them basically for any kind of secure transmission of information via internet like money transfers, government communication, secure messaging on social networks and countless others.

\subsection*{Public-Key Cryptosystems}

In public-key cryptosystem each user has to generate a pair of private/public key $(d,e)$. Public key $e$ is revealed and used to encrypt messages $m$. Private key $d$ is kept secret and used to decrypt ciphertext $c$. Public-key cryptosystems have the following four properties:

\begin{itemize}

	\item[(a)] $d$ and $e$ are inverse to each other, formally:

$d(e(m)) = m$

	\item[(b)] both $e$ and $d$ are easy to compute

	\item[(c)] it is impossible or at least infeasible to compute $d$ just by knowing the public-key $e$

	\item[(d)] if a message $m$ is first deciphered an then encrypted, the result is the same, formally:
    
$e(d(m)) = m$

\end{itemize}

The encryption function $e$ has to meet two necessary requirements:

\begin{itemize}

\item \textit{trap-door one-way function} - function is easy to compute in one direction, but it is very difficult to compute inverse of it. Typical examples are prime multiplication vs prime factorization or power modulo vs discrete logarithm. Most of public-key cryptographic protocols are based around these one-way functions.\footnote{WIKI Trapdoor$\_$function}

\item \textit{trap-door one-way permutation} - function is above all also bijective, which means, that $e$ is deterministic 

\end{itemize}

\subsection*{Privacy}

The process of secure data transmission:

\begin{itemize}

\item \textit{encryption} $c = e(m)$ - the sender encrypts the message using the recipient's public key, he obtains the ciphertext $c$ which is then transmitted via channel. An eavesdropper can only see this ciphertext which makes no sense to him provided that he cannot crack the system and decrypt the message

\item \textit{decryption} $m = d(c)$ - the recipient uses his private key to obtain the original sender's message

\end{itemize}

\subsection*{Signature}

The problem of one-way authentication or the message signature is another common event appearing in the network communication. The recipient of the signed message wants to have proof that the message indeed originated from the sender. In this case, sender supplement the message with its signature. It must be easy for anyone to recoginze the signature as authentic, but impossible for anyone other than the legitimate signer to produce it. The process of digital signature is effectively an inverse operation to encryption:

\begin{itemize}

\item \textit{signature} $s = d(m)$ - the sender signs the message using his private key. The signature must be message-dependent, as well as signer-dependent

\item \textit{verification} $m = e(s)$ - the recipient uses the recipient's public key to check, whether the message was sent by him

\end{itemize}

\section{RSA cryptosystem}

On of the first public-key as well as the most commonly used cryptosystem today is RSA. It was publicly described by Rivest, Shamir and Adleman (thus RSA) in 1978\cite{rsa_paper}. RSA gained popularity because of its simplicity, because it uses relativelly simple power modulo operations. It can be implemented in various ways and over the years many different implementations of this protocol have arised. It is widely used in field of software libraries (OpenSSL, Microsoft CryptoAPI, Libcrypt, $\cdots$), cards (Yubikey, Infineon, $\cdots$) or HSM's\footnote{hardware security module}.


\subsection*{Key pair generation}

Every entity that wants to generate a pair of keys is following these steps:

\begin{enumerate}

\item Generate two huge random distinct primes $p$, $q$
\item Compute modulus $n = pq$
\item Choose any public exponent $e$, such that $2 < e < \varphi(n)$\footnote{Euler's totient function, in this case $\varphi(n) = (p-1)(q-1)$} and $e$ is coprime to $\varphi(n)$
\item Compute public exponent $d \equiv e^{-1} \pmod{\varphi(n)}$\footnote{easily computable by Extended Euclidean algorithm}

\end{enumerate}

Detailed key generation process is explained in \cite{thesis_matus_nemec}. The resulted key pair is thus:

\begin{itemize}

\item public key $(n, e)$

\item private key $(d, p, q)$

\end{itemize}

\subsection*{RSA cryptographic primitives}

Every message $m$ can be represented as a positive integer between 0 and $n-1$.\footnote{in case of longer messages we would just need to split the message into blocks of integers, where every block would have a value of at most $n-1$} Following cryptographic primitives are present in RSA scheme for message $m$:

\begin{itemize}

\item \textit{encryption} $c \equiv m^e \pmod{n}$
\item \textit{decryption} $m \equiv c^d \pmod{n}$
\item \textit{signature} $s \equiv m^d \pmod{n}$
\item \textit{signature verification} $m \equiv s^e \pmod{n}$

\end{itemize}

\noindent
These power modulo operations can be computed very effectively.

\subsection{Generation bias}

While implementing RSA, many individual sources implement finding candidate primes $p,q$, and public/private exponents $d,e$ differently. Some of them are actively avoiding various properties of primes, which can then lead to the restriction on sample space of available prime numbers:

\begin{itemize}

\item \textit{OpenSSL} is rejecting any candidate, which is congruent to 1 modulo any prime up to 17863 as first reported by Mironov\cite{mironov}

\item smartcard \textit{Infineon JTOP 80K} is generating such primes, which when divided by 11 give a remainder of 1 or 10, by 37 a remainder of 1, 10 or 26 and others

\item some sources like \textit{G\&D SmartCafe 4.x} and \textit{G\&D SmartCafe 6.0} are using only Blum primes\footnote{A prime $p$ is a Blum prime if $p \equiv 3 \pmod{4}$}, which means, that the resulting public key is always congruent to 1

\end{itemize}

These decisions in the process of generation leave significant bias in some sources. When connecting given public-key to its source, one can look at these properties and with high probability differentiate between sources and correctly classify public-key.

We looked at some basic properties for our dataset and found bias in several sources. Full list can be seen in appendix \ref{appendix-analysis}. These features are used for machine learning classifiers.

\subsection*{sources}


\textbf{NOTES:}
\begin{itemize}
\item convention Alice and Bob
\item RSA no proof on security of factorization
\item one-way function
\item one-way permutation
\item factorization/discrete log
\item \url{https://en.wikipedia.org/wiki/Public-key_cryptography}
\end{itemize}
